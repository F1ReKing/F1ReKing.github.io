<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Android7.0使用webview遇到的一个坑]]></title>
    <url>%2F2017%2F07%2F07%2Fandroid-webview-keng%2F</url>
    <content type="text"><![CDATA[这是一篇android7.0使用webview的时候一个坑的解决方案。 之前对于webview的使用做了总结，以为坑应该都吃掉了，没想到今天发版后才发现有一个大坑： 在Android7.0+，第一个加载webview显示是完全没有问题的，但当点击webview内容进行二级页面跳转后，就会显示一片空白，查询了url是正常可以打开的，这就坑了！！ 遇到问题，解决问题！！！ 首先，凭过去前端开发经验，出现空白页面就是url为about:blank，于是就在onPageFinished()的回调里对url打个log，果然输出是about:blank。 12345@Overridepublic void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); Log.i("TAG",url);&#125; 接下去就是定位shouldOverrideUrlLoading()这个回调方法，应该是loadUrl的时候出了问题。 1234567//在webview内加载url@Overridepublic boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; view.loadUrl(request.toString()); Log.i(TAG, request.toString()); return true;&#125; 打开Log一看，果然load的是一个对象，而不是一个url。然后跟踪到request中持有getUrl()方法，所以直接调用就出错了，经查询只有在5.0系统才能用，所以只要做个兼容判断就可以了。 最终处理方案为： 12345678910//在webview内加载url@Overridepublic boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; view.loadUrl(request.getUrl().toString()); &#125; else &#123; view.loadUrl(request.toString()); &#125; return true;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-emotion]]></title>
    <url>%2F2017%2F07%2F05%2Fandroid-emotion%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[谈谈Kotlin]]></title>
    <url>%2F2017%2F05%2F24%2FKotlin%2F</url>
    <content type="text"></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac JDK版本切换]]></title>
    <url>%2F2017%2F04%2F20%2FMac-JDK-Change%2F</url>
    <content type="text"><![CDATA[本篇是通过命令轻松切换到对应的Java版本教程。 由于开发Android项目现在基本用到JDK8，但最近在搞JavaWeb项目需要用到JDK7而已，所以需要同时有多个版本的JDK并存，就研究下如何并存。 目标：通过命令’jdk7’,’jdk8’轻松切换到对应的jdk版本，默认初始为jdk7。 做法： 安装所有的JDK： 自行到Oracle官网下载安装对应的版本，由于Oracle官网已经下不到JDK7的安装包，所以这里我可以提供下载：百度云：密码34bj 配置： 创建.bash_profile配置文件（若已经有该文件直接跳过此步骤） 1touch ~/.bash_profile 编辑.bash_profile 1vim ~/.bash_profile 设置jdk版本 123export JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0.jdk/Contents/Homeexport JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Homeexport JAVA_HOME=$JAVA_7_HOME alias命令动态切换配置 12alias jdk8=&apos;export JAVA_HOME=$JAVA_8_HOME&apos;alias jdk7=&apos;export JAVA_HOME=$JAVA_7_HOME&apos; 重新执行.bash_profile文件 1source ~/.bash_profile 验证：使用jdk7、jdk8命令即可切换jdk版本]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存泄漏解析]]></title>
    <url>%2F2017%2F03%2F01%2Fmemory-leak-analysis%2F</url>
    <content type="text"><![CDATA[本篇对于Android中内存泄漏进行解析。 前言相对于C/C++的内存泄漏是new出来的对象没有delete，而java中内存泄漏是new出来的对象放在Heap上无法被GC回收，所以对于内存泄漏，在开发过程中不可轻易忽视。 杂谈首先谈谈Java的内存分配： 静态存储区： 编译时就分配好，在程序整个运行期间都存在，主要存放静态数据和常量； 栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存； 堆区：通常用来存放new出来的对象，由java垃圾回收期回收。 对于java垃圾回收机制回收不同引用类型的介绍： 强引用(StrongRefrrence)： JVM宁可抛出OOM，也不会让GC回收具有强引用的对象； 软引用(SoftReference)：只有在内存空间不足时，才会被回收的对象； 弱引用(WeakReference)：在GC时，一旦发现只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存； 虚引用(PhantomReference)：任何时候都可以被GC回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。 总结为以下： 级别 回收时机 用途 生存时间 强 从来不会 对象的一般状态 JVM停止运行时终止 软 在内存不足时 联合ReferenceQueue构造有效期短/占内存大/生命周期长的对象的二级高速缓冲器（内存不足才清空） 内存不足时终止 弱 在垃圾回收时 联合ReferenceQueue构造有效期短/占内存大/生命周期长的对象的一级高速缓冲器（系统发生gc则清空） gc运行后终止 虚 在垃圾回收时 联合ReferenceQueue来跟踪对象被垃圾回收器回收的活动 gc运行后终止 内存泄漏解析1.持有Contextcontext是最容易忽视的，很多情况下我们可能随意传递context，例如给一个类传递context的时候经常用Activity，但该类持有对Activity的全部引用，当Activity关闭的时候因为被其他类持有，而导致无法正常被回收，从而导致内存泄漏。 解决方案： 在给类传递context的时候使用Application对象，避免依赖activity的生命周期，但谨慎对context使用static关键字。 2.HandlerHandler是最容易造成内存泄漏的，如果Handler中有延迟的任务或是等在执行的队列过长，由于消息队列持有对Handler的引用，而Handler又持有actvity的隐式引用，这个引用会保持到消息得到处理，而导致activity无法被垃圾回收器进行回收，而导致内存泄漏。 解决方案： 把Handler放到单独的类中，或者使用静态的内部类避免泄漏 如果想要在Handler内部去调用Activity中的资源，可以在Handler中使用弱引用的方式指向所在的Activity，使用static+WeakReference的方式断开handler与activity的关系 3.单例模式在使用单例模式的时候如果使用不当也是会造成内存泄漏的，因为单例膜撕的静态特征使得单例模式的生命周期和应用一样的长，这说明了当一个对象不需要使用了，而单例对象还存在该对象的引用，那么这个对象就不能正常的被回收，导致内存泄漏。 解决方案： 在构建单例模式时，我们经常会传入Activity的context，当Activity退出之后，单例对象还持有他的引用，所以为了避免传Activity的context，在单例中通过传入的context获取到全局的上下文对象，而不适用Activity的Context就解决了这个问题。 4.非静态内部类创建静态实例在非静态的内部类默认会持有外部类的引用，而我们又使用非静态内部类创建了一个静态的实例，该静态实例的声明周期和应用一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity不能正常回收。 解决方案： 将内部类修改成静态的，这样它对外部类就没有引用 将该对象抽取出来封装成一个单例。 5.线程我们在使用线程时，一般都使用匿名内部类，而匿名内部类会对外部类持有默认的引用，当Activity关闭之后如果现成中的任务还没有执行完毕，就会导致Activity不能正常回收，造成内存泄漏。 解决方案： 创建一个静态的类，实现Runnable方法，在使用的时候实例化。 6.资源未关闭对于使用了BroadcastReceiver、ContentObserver、File、Cursor、Stream、Bitmap等资源，应该在Activity销毁时及时关闭或者注销掉，否则这些资源不会被回收，造成内存泄漏。 7.监听器未注销在很多地方需要register的监听器，要确保及时unregister监听器。 8.WebViewwebView是个坑，很难驾驭，如果你在webView有js连调中有线程处理，不再需要使用webView的时候，应该调用它的destory()销毁，释放其占用的内存，否则其占用的内存长期也不能回收，从而造成内存泄漏。 9.集合容器我们通常会把一些对象的引用加入到集合容器（比如ArrayList）中，当我们不再需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。 解决方案： 所以在退出程序之前，将集合里面的东西clear，然后置为null，再退出程序。 内存泄漏检测工具对于检测工具，我推荐两种： MAT(Memory Analyzer Tool)，具体使用方法网上很多。 LeakCanary，这是我近2年一直在用的一个检测库，配置简单，抓捕率高，但某些机型上有些bug，所以开发阶段可以用，发版建议关闭。 总结 构造Adapter时，没有使用缓存的 convertView Bitmap对象不在使用时调用recycle()释放内存 Context使用不当造成内存泄露：不要对一个Activity Context保持长生命周期的引用。尽量在一切可以使用应用ApplicationContext代替Context的地方进行替换。 非静态内部类的静态实例容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。 警惕线程未终止造成的内存泄露；譬如在Activity中关联了一个生命周期超过Activity的Thread，在退出Activity时切记结束线程。一个典型的例子就是HandlerThread的run方法是一个死循环，它不会自己结束，线程的生命周期超过了Activity生命周期，我们必须手动在Activity的销毁方法中中调运thread.getLooper().quit();才不会泄露。 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。 不要在执行频率很高的方法或者循环中创建对象（比如onmeasure），可以使用HashTable等创建一组对象容器从容器中取那些对象，而不用每次new与释放。 避免代码设计模式的错误造成内存泄露；譬如循环引用，A持有B，B持有C，C持有A，这样的设计谁都得不到释放。 参考 Android内存泄漏解决方案(OOM) 内存泄漏全解析，从此拒绝ANR，让OOM远离你的身边，跟内存泄漏say byebye]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome for Mac键盘快捷键整理]]></title>
    <url>%2F2017%2F01%2F20%2Fmac-chrome-keyboard-shortcuts%2F</url>
    <content type="text"><![CDATA[本篇是对Mac中chrome的键盘快捷键整理。本篇整理自官网http://support.google.com/chrome/bin/answer.py?hl=zh-Hans&amp;answer=165450 标签页和窗口快捷键 快捷键 说明 ⌘-N 打开新窗口。 ⌘-T 打开新标签页。 ⌘-Shift-N 在隐身模式下打开新窗口。 按 ⌘-O，然后选择文件。 在 Google Chrome 浏览器中打开计算机中的文件。 按住 ⌘ 键，然后点击链接。或用鼠标中键（或鼠标滚轮）点击链接。 从后台在新标签页中打开链接。 按住 ⌘-Shift 键，然后点击链接。或按住 Shift 的同时用鼠标中键（或鼠标滚轮）点击链接。 在新标签页中打开链接并切换到刚打开的标签页。 按住 Shift 键，然后点击链接。 在新窗口中打开链接。 ⌘-Shift-T 重新打开上次关闭的标签页。Google Chrome 浏览器可记住最近关闭的 10 个标签页。 将标签页拖出标签栏。 在新窗口中打开标签页。 将标签页从标签栏拖到现有窗口中。 在现有窗口中打开标签页。 同时按 ⌘-Option 和向右箭头键。 切换到下一个标签页。 同时按 ⌘-Option 和向左箭头键。 切换到上一个标签页。 ⌘-W 关闭当前标签页或弹出窗口。 ⌘-Shift-W 关闭当前窗口。 点击并按住浏览器工具栏中的后退或前进箭头。 在新标签页中显示浏览历史记录。 按 Delete 或 ⌘-[ 转到当前标签页的上一页浏览历史记录。 按 Shift-Delete 或 ⌘-] 转到当前标签页的下一页浏览历史记录。 按住 Shift，然后点击窗口左上方的 + 按钮。 最大化窗口。 ⌘-M 最小化窗口。 ⌘-H 隐藏 Chrome 浏览器。 ⌘-Option-H 隐藏其他所有窗口。 ⌘-Q 关闭 Google Chrome 浏览器。 Google Chrome 浏览器功能快捷键 快捷键 说明 ⌘-Shift-B 打开和关闭书签栏。 ⌘-Option-B 打开书签管理器。 ⌘-, 打开“偏好设置”对话框。 ⌘-Y 打开“历史记录”页面。 ⌘-Shift-J 打开“下载内容”页面。 ⌘-Shift-Delete 打开“清除浏览数据”对话框。 ⌘-Shift-M 在多个用户之间切换。 地址栏快捷键 快捷键 说明 输入搜索字词，然后按 Enter。 使用默认搜索引擎进行搜索。 输入搜索引擎关键字，按空格键，然后输入搜索字词，再按 Enter。 使用与关键字相关联的搜索引擎进行搜索。 首先输入搜索引擎网址，然后在系统提示时按 Tab，输入搜索字词，再按 Enter。 使用与网址相关联的搜索引擎进行搜索。 输入网址，然后按 ⌘-Enter。 在新后台标签页中打开网址。 ⌘-L 突出显示网址。 ⌘-Option-F 将“?”置于地址栏中。在问号后输入搜索字词可用默认搜索引擎执行搜索。 同时按 Option 和向左箭头键。 将光标移到地址栏中的前一个关键字词 同时按 Option 和向右箭头键。 在地址栏中将光标移到下一个关键字词 同时按 Shift-Option 和向左箭头键。 在地址栏中突出显示上一关键字词 同时按 Shift-Option 和向右箭头键。 在地址栏中突出显示下一关键字词 ⌘-Delete 在地址栏中删除光标前的关键字词 用键盘上的方向键从地址栏下拉菜单中选择一个条目，然后按 Shift-Fn-Delete。 从浏览历史记录中删除所选条目（如果可以）。 在地址栏菜单中按 Page Up 或 Page Down。 在菜单中选择上一条目或下一条目。 网页快捷键 快捷键 说明 ⌘-P 打印当前网页。 ⌘-Shift-P 打开“网页设置”对话框。 ⌘-S 保存当前网页。 ⌘-Shift-I 通过电子邮件发送当前网页。 ⌘-R 重新加载当前网页。 ⌘-, 停止加载当前网页。 ⌘-F 打开查找栏。 ⌘-G 在查找栏中查找下一条与输入内容相匹配的内容。 ⌘-Shift-G 或 Shift-Enter 在查找栏中查找上一条与输入内容相匹配的内容。 ⌘-E 使用所选内容查找 ⌘-J 跳到所选内容 ⌘-Option-I 打开开发者工具。 ⌘-Option-J 打开“JavaScript 控制台”。 ⌘-Option-U 打开当前网页的源代码。 按住 Option，然后点击链接。 下载链接目标。 将链接拖到书签栏中。 将链接保存为书签。 ⌘-D 将当前网页保存为书签。 ⌘-Shift-D 将所有打开的标签页以书签的形式保存在新文件夹中。 ⌘-Shift-F 在全屏模式下打开网页。再按一次 ⌘-Shift-F 可退出全屏模式。 ⌘-+ 放大网页上的所有内容。 ⌘ 和 - 缩小网页上的所有内容。 ⌘-0 将网页上的所有内容都恢复到正常大小。 ⌘-Shift-H 在当前标签页中打开主页。 空格键 向下滚动网页。 ⌘-Option-F 搜索网页。 文本快捷键 快捷键 说明 ⌘-C 将突出显示的内容复制到剪贴板中。 ⌘-Option-C 将您正在查看的网页的网址复制到剪贴板中。 ⌘-V 从剪贴板中粘贴内容。 ⌘-Shift-Option-V 仅粘贴内容，不带源格式。 ⌘-X 或 Shift-Delete 删除突出显示的内容并将其复制到剪贴板中。 ⌘-Z 撤消最后一步操作。 ⌘-Shift-Z 重复最后一步操作。 ⌘-X 删除突出显示的内容并将其保存到剪贴板中（剪切）。 ⌘-A 选择当前网页上的所有文本。 ⌘-: 打开“拼写和语法”对话框。 ⌘-; 检查当前网页上的拼写和语法]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用DownloadManager进行版本更新（兼容7.0）]]></title>
    <url>%2F2017%2F01%2F16%2FAndroid-DownloadManager%2F</url>
    <content type="text"><![CDATA[本篇对于Android中对于DownloadManager的使用经验分享。 概述DownloadManager是Android SDK中封装的下载文件类，可以很方便开发者使用下载文件。其具体看官方APIhttps://developer.android.com/reference/android/app/DownloadManager.html 正文 使用DownloadManager下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class DownloadUtils &#123; private DownloadManager mDownloadManager; private Context mContext; private long downloadId; private String apkName; public DownloadUtils(Context context) &#123; mContext = context; &#125; public void download(String url, String name) &#123; final String packageName = "com.android.providers.downloads"; int state = mContext.getPackageManager().getApplicationEnabledSetting(packageName); //检测下载管理器是否被禁用 if (state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(mContext).setTitle("温馨提示").setMessage ("系统下载管理器被禁止，需手动打开").setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); try &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.parse("package:" + packageName)); mContext.startActivity(intent); &#125; catch (ActivityNotFoundException e) &#123; Intent intent = new Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS); mContext.startActivity(intent); &#125; &#125; &#125;).setNegativeButton("取消", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;); builder.create().show(); &#125; else &#123; //正常下载流程 apkName = name; DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url)); request.setAllowedOverRoaming(false); //通知栏显示 request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED); request.setTitle(AppUtils.getAppName(mContext)); request.setDescription("正在下载中..."); request.setVisibleInDownloadsUi(true); //设置下载的路径 request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, apkName); //获取DownloadManager mDownloadManager = (DownloadManager) mContext.getSystemService(Context.DOWNLOAD_SERVICE); downloadId = mDownloadManager.enqueue(request); mContext.registerReceiver(mReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE)); &#125; &#125; private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; checkStatus(); &#125; &#125;; /** * 检查下载状态 */ private void checkStatus() &#123; DownloadManager.Query query = new DownloadManager.Query(); query.setFilterById(downloadId); Cursor cursor = mDownloadManager.query(query); if (cursor.moveToFirst()) &#123; int status = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)); switch (status) &#123; //下载暂停 case DownloadManager.STATUS_PAUSED: break; //下载延迟 case DownloadManager.STATUS_PENDING: break; //正在下载 case DownloadManager.STATUS_RUNNING: break; //下载完成 case DownloadManager.STATUS_SUCCESSFUL: installAPK(); break; //下载失败 case DownloadManager.STATUS_FAILED: Toast.makeText(mContext, "下载失败", Toast.LENGTH_SHORT).show(); break; &#125; &#125; cursor.close(); &#125; /** * 7.0兼容 */ private void installAPK() &#123; File apkFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), apkName); Intent intent = new Intent(Intent.ACTION_VIEW); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; Uri apkUri = FileProvider.getUriForFile(mContext, mContext.getPackageName() + ".provider", apkFile); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.setDataAndType(apkUri, "application/vnd.android.package-archive"); &#125; else &#123; intent.setDataAndType(Uri.fromFile(apkFile), "application/vnd.android.package-archive"); &#125; mContext.startActivity(intent); &#125;&#125; 在Manifest中添加使用权限 12&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 在Manifest中添加7.0私有文件权限 123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="$&#123;applicationId&#125;.provider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/provider_paths"/&gt;&lt;/provider&gt; 建立xml私有文件权限配置在res中建立xml文件夹，建立provider_paths.xml文件，文件中： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;paths&gt; &lt;external-path name="download" path=""/&gt; &lt;/paths&gt;&lt;/resources&gt; 后记 已兼容7.0私有文件权限问题 对于部分机型默认或者一些原因，下载管理器是被禁用掉的，必须手动开启或者写代码去跳转到设置界面开启，代码中已兼容。 参考 Android系统下载管理DownloadManager功能介绍及使用示例]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速集成友盟多渠道打包]]></title>
    <url>%2F2017%2F01%2F16%2FUMeng-package%2F</url>
    <content type="text"><![CDATA[本篇针对快速集成友盟多渠道打包的经验分享 概述依个人理解，多渠道只是给运营数据统计方便查看而已，并不是个技术，虽然以前面试的时候有被问到会不会多渠道打包，不过说实在，如果你公司的项目没有要求数据统计，一般不会有多渠道统计的，所以即使要用，也能很快集成的，首先还是放出官网的文档：http://dev.umeng.com/analytics/android-doc/integration,本篇就是让你快速集成，不用再去翻看文档。 步骤 先注册账号，并建立新应用，拿到Appkey 导入SDK 在app的gradle依赖中添加： 123dependencies &#123; compile &apos;com.umeng.analytics:analytics:latest.integration&apos;&#125; 在project的gradle中添加 12345allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 配置Appkey.在manifest中配置权限及appkey 12345678910&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET"/&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;&lt;application ……&gt;……&lt;activity ……/&gt;&lt;meta-data android:value="YOUR_APP_KEY" android:name="UMENG_APPKEY"/&gt;&lt;meta-data android:value="$&#123;UMENG_CHANNEL_VALUE&#125;" android:name="UMENG_CHANNEL"/&gt;&lt;/application&gt; 注意：在android6.0之后会有权限检查问题，若要正常使用，请在代码中手动配置权限，这里不再祥述。 代码集成统计在每个Activity集成下列代码，建议配置在BaseActivity里： 12345678public void onResume() &#123;super.onResume();MobclickAgent.onResume(this);&#125;public void onPause() &#123;super.onPause();MobclickAgent.onPause(this);&#125; 打包当所有步骤做好之后，接下来就是多渠道打包的事了。 首先是代码代码混淆： 1234567-keepclassmembers class * &#123; public &lt;init&gt; (org.json.JSONObject);&#125;-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125; 配置渠道号 在gradle配置渠道号 12345678910productFlavors &#123; xiaomi &#123;&#125; _360 &#123;&#125; baidu &#123;&#125; wandoujia &#123;&#125; &#125; productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125; 打包 1./gradlew assembleRelease 后记 目前这种打包方式很慢，要快速打包我推荐看美团多渠道打包 之后有空再来扩展…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bye2016Hi2017]]></title>
    <url>%2F2016%2F12%2F31%2FBye2016Hi2017%2F</url>
    <content type="text"><![CDATA[Be the change you want to see in the world. 2016一整年还算顺利，年初被4399因入职体检原因被退offer，给自己放假了2个月在家休养生息，也想通了自己这一年要走的路，我要做产品，年后加入一家创业公司，做一款公司自己的产品，独立负责Android端的开发工作，突破了自己过去的技术障碍，入手了2016的愿望清单，把想看的书都看了，走吧，2016，过去的你，我还算顺利。 2017接下来的一年要继续加油努力，把技术提高到中上水平，把技术全栈化，把薪资提高一个层次，github上多贡献开源，每周至少一篇博客。 书单列表： Android开发艺术探索 Android源码设计模式 心愿单： 减重 早睡早起 制定每天工作计划 不忘初心，不忘初心]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中WebView指南]]></title>
    <url>%2F2016%2F12%2F04%2FAndroid-webview%2F</url>
    <content type="text"><![CDATA[so,在Android系统中内置了webkit内核浏览器，Android中有个组件叫WebView，能够在应用中展示web界面，此篇就剥解WebView的一切。 WebView简介为了开发者能够实现在app内展示网页内容并与网页交互的需求， WebView基本使用WebView API详解WebSettingsWebViewClientWebChromeClientJavaScript与WebView交互WebView加载优化WebView使用经验]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中shape的特性详解]]></title>
    <url>%2F2016%2F12%2F01%2FAndroid-shape%2F</url>
    <content type="text"><![CDATA[本文针对shape中的属性进行详解 shape首先讲下shape，shape可以自定义形状，可以定义以下四种类型，通过android:shape属性定义： rectangle：矩形，可以画出各种矩形。 oval：椭圆形，也可以用来画正圆形。 line：线形，可以画实线和虚线。 ring：环形，可以画环形进度条。 接下来对于属性进行详解： corners：设置圆角 android:radius 圆角半径，四个角 android:topLeftRadius 左上角的圆角半径 android:topRightRadius 右上角的圆角半径 android:bottomLeftRadius 左下角的圆角半径 android:bottomRightRadius 右下角的圆角半径 gradient：设置形状的渐变颜色，可以是线性渐变、辐射渐变、扫描性渐变 android:type 渐变的类型 linear 线性渐变，默认 radial 放射渐变，设置该项时，android:gradientRadius也必须设置 sweep 扫描渐变 android:startColor 渐变开始的颜色 android:endColor 渐变结束的颜色 android:centerColor 渐变中间的颜色 android:angle 渐变的角度，线性渐变时才有效，必须是45的倍数，0表示从左到右，90表示从下到上 android:centerX 渐变中心的相对X坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:centerY 渐变中心的相对Y坐标，放射渐变时才有效，在0.0到1.0之间，默认为0.5，表示在正中间 android:gradientRadius 渐变的半径，只有渐变类型为radial时才能使用 android:useLevel 如果为true，则可以在LevelListDrawable中使用 padding：设置内容与形状边界的内间距 android:left 左内间距 android:right 右内间距 android:top 上内间距 android:bottom 下内间距 size：设置大小 android:width 设置宽度 android:height 设置高度 solid：设置形状的填充颜色 android:color 填充的颜色 stroke：设置描边 android:color 描边的颜色 android:width 描边的宽度 android:dashWidth 设置虚线时的横线长度 android:dashGap 设置虚线时的横线之间的距离 使用经验 画线时需注意： 只能画水平线，画不了竖线； 线的高度是通过stroke的android:width属性设置的； size的android:height属性定义的是整个形状区域的高度； size的height必须大于stroke的width，否则，线无法显示； 线在整个形状区域中是居中显示的； 线左右两边会留有空白间距，线越粗，空白越大； 引用虚线的view需要添加属性android:layerType，值设为”software”，否则显示不了虚线。 当shape根元素为ring类型时，需要在根元素用以下属性： android:innerRadius 内环的半径 android:innerRadiusRatio 浮点型，以环的宽度比率来表示内环的半径，默认为3，表示内环半径为环的宽度除以3，该值会被android:innerRadius覆盖 android:thickness 环的厚度 android:thicknessRatio 浮点型，以环的宽度比率来表示环的厚度，默认为9，表示环的厚度为环的宽度除以9，该值会被android:thickness覆盖 android:useLevel 一般为false，否则可能环形无法显示，只有作为LevelListDrawable使用时才设为true 本文参考： http://keeganlee.me/post/android/20150830]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中EditText的一切]]></title>
    <url>%2F2016%2F11%2F30%2FAndroid-edittext%2F</url>
    <content type="text"><![CDATA[本篇我想总结下关于EditText控件的使用和遇到的问题 可以，不跟你多bb，基本知识请直接看Android Developers中关于EditText的API，本篇问题也大多于查看api之后的方法总结。 问题 经常碰到界面初始化后EditText就会自动获取焦点并弹出输入法，这样的用户体验很不好，所以我们可以禁止输入法自动弹出。解决方案：方案1：在Activity的onCreate()方法中加入：getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);方案2：在Manifest文件中的Activity注册标签下，加入属性：android:windowSoftInputMode=&quot;statehidden&quot; 用户在使用EditText进行输入后，我们可以利用软键盘上特色功能进行导航，提高用户体验。在xml中添加属性：android:imeOptions.actionGo 输入法右下角显示“去往”.actionSearch 输入法右下角显示“搜索”.actionSend 输入法右下角显示“发送”.actionNext 输入法右下角显示“下一个”.actionDone 输入法右下角显示“完成”.actionPrevious 输入法右下角显示“上一个”.给EditText设置OnEditorActionListener，代码如下： 1234567891011121314151617181920private OnEditorActionListener actionListener = new OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; switch (v.getId()) &#123; case R.id.et_first: if(actionId == EditorInfo.IME_ACTION_SEND) &#123; //进行处理 &#125; break; case R.id.et_second: if(actionId == EditorInfo.IME_ACTION_SEARCH) &#123; //进行处理 &#125; break; default: break; &#125; return false; &#125; &#125;; 注意：必须在xml上加上12android:maxLines="1" android:inputType="text" 中其中一个才能使用这个导航功能，或者用java代码也行12editText.setInputType(EditorInfo.TYPE_CLASS_TEXT); editText.setSingleLine(true);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android接入支付SDK]]></title>
    <url>%2F2016%2F11%2F28%2FAndroid-sdk-pay%2F</url>
    <content type="text"><![CDATA[最近公司项目做到支付模块，之前也做过，没整理成博客，这次整理一下。 微信支付前期准备 注册账号，创建应用，开通微信支付。 查看APP支付文档：https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_1 了解支付流程： 接入SDK 引入libs，下载https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1，并将libammsdk.jar放到libs文件夹下。 配置签名在debug下直接配置key，这样就可以在debug下调试了。 12345678910111213141516171819202122signingConfigs &#123; debug &#123; storeFile file("你的keystore文件路径") storePassword "xxx" keyAlias "xxx" keyPassword "xxx" &#125; release &#123; storeFile file("你的keystore文件路径") storePassword "xxx" keyAlias "xxx" keyPassword "xxx" &#125;&#125;buildTypes &#123; debug &#123; signingConfig signingConfigs.debug &#125; release &#123; signingConfig signingConfigs.release &#125; &#125; 创建WXPayEntryActivity在报名下创建如下图的Activity，demo里也有，WXPaEntryActivity是支付的回调，WXEntryActivity是微信登录和分享的回调。 AndroidManifest.xml中注册 1234567&lt;activity android:name=".wxapi.WXPayEntryActivity" android:exported="true" android:launchMode="singleTop" android:screenOrientation="portrait" android:theme="@android:style/Theme.Translucent.NoTitleBar" android:windowSoftInputMode="stateHidden"/&gt; 加入混淆 12-libraryjars libs/libammsdk.jar-keep class com.tencent.** &#123; *;&#125; 接口调用123456789101112131415161718192021222324/** * 调用微信支付 * @param datas 微信支付数据 */private void toWXPay(String datas) &#123; IWXAPI api = WXAPIFactory.createWXAPI(PayActivity.this, WX_APP_ID); api.registerApp(WX_APP_ID); try &#123; JSONObject jsonObject = new JSONObject(datas); PayReq req = new PayReq(); req.appId = jsonObject.getString("appid");// 微信开放平台appid req.nonceStr = jsonObject.getString("noncestr");// 随机字符串 req.packageValue = jsonObject.getString("package");// 支付内容 req.partnerId = jsonObject.getString("partnerid");// 财付通id req.prepayId = jsonObject.getString("prepayid");// 微信预支付编号 req.sign = jsonObject.getString("sign");// 签名 req.timeStamp = jsonObject.getString("timestamp");// 时间戳 req.extData = "app data"; // optional // 在支付之前，如果应用没有注册到微信，应该先调用IWXMsg.registerApp将应用注册到微信 api.sendReq(req); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125;&#125; 支付回调12345678910111213141516171819202122232425262728293031323334353637383940414243public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler &#123; private IWXAPI api; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); api = WXAPIFactory.createWXAPI(this, Config.WX_APP_ID); api.handleIntent(getIntent(), this); &#125; @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); setIntent(intent); api.handleIntent(intent, this); &#125; @Override public void onReq(BaseReq req) &#123; &#125; @Override public void onResp(BaseResp resp) &#123; if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123; switch (resp.errCode) &#123; case 0: Toast.makeText(this, "支付成功", Toast.LENGTH_SHORT).show(); break; case -1: Toast.makeText(this, "支付失败，请检查", Toast.LENGTH_SHORT).show(); break; case -2: Toast.makeText(this, "已取消支付", Toast.LENGTH_SHORT).show(); break; default: Toast.makeText(this, "支付失败，请检查", Toast.LENGTH_SHORT).show(); break; &#125; finish(); &#125; &#125;&#125; 遇到的问题 未安装微信客户端的情况下使用，然后会发现提示E/ActivityThread: Failed to find provider info for com.tencent.mm.sdk.plugin.provider，因为微信没有html5页面能使用支付，所以我们必须要在使用支付之前做个判断，因为微信sdk有提供个参数可以判断，所以应该加上： 123456789101112private boolean isWXAppInstall() &#123; IWXAPI api = WXAPIFactory.createWXAPI(PayActivity.this, WX_APP_ID); api.registerApp(WX_APP_ID); boolean isWXAppInstalled = api.isWXAppInstalled() &amp;&amp; api.isWXAppSupportAPI(); return isWXAppInstalled;&#125;if (isWXAppInstall()) &#123; DialogUtil.showProDialog(PayActivity.this); toWXPay(datas);&#125; else &#123; Toast.makeText(this, "未安装微信客户端", Toast.LENGTH_SHORT).show();&#125; Android7.0上会出现回调成功重复多次，这个待再次确认，可能是微信的bug。 支付宝支付前期准备 注册账号，创建应用，开通支付功能。 查看文档:支付文档 了解支付流程： 接入SDK 引入libs，下载支付宝SDK及DEMO，并将alipaySdk-xx.jar包放到libs文件夹下 AndroidManifest.xml中注册 12345678910&lt;activity android:name="com.alipay.sdk.app.H5PayActivity" android:configChanges="orientation|keyboardHidden|navigation" android:exported="false" android:screenOrientation="behind"/&gt;&lt;activity android:name="com.alipay.sdk.auth.AuthActivity" android:configChanges="orientation|keyboardHidden|navigation" android:exported="false" android:screenOrientation="behind"/&gt; 加入权限 12345&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 加入混淆 1234567-libraryjars libs/alipaySdk-xx.jar-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125; 接口调用支付宝的demo已经写得很明了易懂了，这里简单列出接口调用的主要代码，其他代码请看支付宝DEMO。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 调取支付宝SDK * * @param payInfo 支付信息 */private void alipay(final String payInfo) &#123; Runnable payRunnable = () -&gt; &#123; PayTask alipay = new PayTask(PayActivity.this); String result = alipay.pay(payInfo, true); Message msg = new Message(); msg.what = SDK_PAY_FLAG; msg.obj = result; mHandler.sendMessage(msg); &#125;; Thread payThread = new Thread(payRunnable); payThread.start();&#125;/** * 支付宝支付回调处理 */@SuppressLint("HandlerLeak")private Handler mHandler = new Handler() &#123; @SuppressWarnings("unused") public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SDK_PAY_FLAG: &#123; PayResult payResult = new PayResult((String) msg.obj); String resultInfo = payResult.getResult();// 同步返回需要验证的信息 String resultStatus = payResult.getResultStatus(); // 判断resultStatus 为“9000”则代表支付成功，具体状态码代表含义可参考接口文档 if (TextUtils.equals(resultStatus, "9000")) &#123; Toast.makeText(PayActivity.this, "支付成功", Toast.LENGTH_SHORT).show(); &#125; else &#123; if (TextUtils.equals(resultStatus, "8000")) &#123; Toast.makeText(PayActivity.this, "支付结果确认中", Toast.LENGTH_SHORT).show(); &#125; else &#123; // 其他值就可以判断为支付失败，包括用户主动取消支付，或者系统返回的错误 Toast.makeText(PayActivity.this, "支付失败", Toast.LENGTH_SHORT).show(); &#125; &#125; break; &#125; default: break; &#125; &#125;&#125;; 遇到的问题 很容易遇到的问题就是支付参数遗漏，可以直接查看文档 还会可能遇到支付错误，可以直接查看文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Activity]]></title>
    <url>%2F2016%2F11%2F23%2FAndroid-Activity%2F</url>
    <content type="text"><![CDATA[最近打算整理下之前的学习笔记，这篇是关于学习Activity的小结 Activity的四种launchModelaunchMode在多个Activity跳转的过程中扮演着重要的角色，它可以决定是否生成新的Activity实例，是否重用已存在的Activity实例，是否和其他Activity实例公用一个task里。task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。Activity一共有四个launchMode： standard singleTop singleTask singleInstance 我们可以在AndroidManifest.xml中配置的android:launchMode属性填上以上四种之一。 standrad这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。 singleTask如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之Service]]></title>
    <url>%2F2016%2F11%2F23%2FAndroid-Service%2F</url>
    <content type="text"><![CDATA[对Android的Service组件写个小结 ServiceService有几种启动方式Service是一个专门在后台处理长时间任务的Android组件，它没有UI。它有两种启动方式，startService和bindService，结束用stopService和unBindService。 两种方式的区别 startService只是启动Service，启动它的组件（如Activity）和Service并没有关联，只有当Service调用stopSelf或者其他组件调用stopService服务才会终止。 bindService方法启动Service，其他组件可以通过回调获取Service的代理对象和Service交互，而这两方也进行了绑定，当启动方销毁时，Service也会自动进行unBind操作，当发现所有绑定都进行了unBind时才会销毁Service。 生命周期比较 Service的onCreate回调函数可以做耗时的操作吗？不可以，Service的onCreate是在主线程(ActivityThread)中调用的，耗时操作会阻塞UI，如果你只需要在当前界面去做一些耗时操作，界面退出或改变时，工作也要停止，那么这时直接使用Thread(或者AsyncTask,ThreadHandler)会更合适你。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的“再按一次返回键退出程序”的改进]]></title>
    <url>%2F2016%2F11%2F19%2FAndroid-app-exit%2F</url>
    <content type="text"><![CDATA[最近在优化公司项目的代码，发现以前的坑很多，我慢慢地在填，今天就发现了一个坑，就是首页的“再按一次返回键退出程序“功能，所以这个坑，我就填了。 首先，项目里的版本代码是这样的：1234567891011121314151617181920212223242526272829private static boolean isExit = false;Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); isExit = false; &#125; &#125;; @Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; exit(); return false; &#125; return super.onKeyDown(keyCode, event); &#125;private void exit() &#123; if (!isExit) &#123; isExit = true; Toast.makeText(MainActivity.this, "再按一次退出程序", Toast.LENGTH_SHORT).show(); mHandler.sendEmptyMessageDelayed(0, 2000); &#125; else &#123; finish(); System.exit(0); &#125; &#125; 这是一种很扯淡的写法，而且用handler有内存泄漏的风险，而且代码也不精简，所以我就填了这个坑。 经过修改直接写个简洁版的：12345678910111213141516private long exitTime = 0;@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &#123; Toast.makeText(MainActivity.this, "再按一次退出程序", Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; finish(); System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; 经过修改后，代码精简易懂。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String、StringBuffer及StringBuilder的区别]]></title>
    <url>%2F2016%2F11%2F17%2FString-StringBuffer-StringBuilder%2F</url>
    <content type="text"><![CDATA[最近在reviews公司项目代码的时候，发现自己三个月前写的代码效率不高，所以都一一去优化，在优化到部分涉及到字符串拼接的问题上时，发现自己以前都没注意到效率，都是String直接拼接，所以就研究下字符串拼接的效率。 String介绍从官网介绍中可看到String是字符串常量，字符串长度不变，它是不可变的。在使用String主要注意的几点： String类初始化后是不可变的 使用String不一定创建对象 使用new String,一定创建对象 StringBuffer介绍从官网介绍中可看到StringBuffer是线程安全的可变字符序列，在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。操作上提供append和insert方法，append方法是将字符添加到缓冲区的末端，而insert方法则能在指定的点添加字符。 StringBuilder介绍从官方介绍知道StringBuilder是一个可变的字符序列，线程是不安全的，速度相较于StringBuffer要更快些。 使用 如果要操作少量的数据，用String； 单线程操作大量数据，用StringBuilder； 多线程操作大量数据，用StringBuffer； 不要使用String的“+”来进行多次拼接，因为性能很差，应该使用StringBuffer或StringBuilder类； 为了获得更好的性能，在构造StringBuffer或StringBuilder时应尽可能指定它们的容量，默认构造容量为16个字符； StringBuilder使用在方法内部来完成类似“+”功能，因为是线程不安全的，所以用完以后可以丢弃掉，StringBuffer主要用在全局变量中； 区别 可变与不可变 String类中使用字符数组保存字符串，private final char value[]中因为有‘final’修饰符，所以String对象是不可变的。 StringBuilder与StringBuffer都继承AbstractStringBuilder类，char[] value可见在AbstractStringBuilder中也是使用字符数组保存字符串，所以这两种对象都是可变的。 是否多线程安全 String中的对象是不可变的，显然线程安全。 StringBuffer对方法加了同步锁，所以是线程安全。 StringBuilder并没有对方法进行加同步锁，所以是非线程安全。 StringBuilder与StringBuffer共同点 StringBuilder与StringBuffer同继承AbstractStringBuilder。共同有公共方法，只是StringBuffer会在方法上加synchronized进行同步。 如果程序不是多线程的，使用StringBuilder效率高于StringBuffer。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterm2设置代理]]></title>
    <url>%2F2016%2F11%2F13%2FIterm2-set-agent%2F</url>
    <content type="text"><![CDATA[因为最近刚用上MacOS，还在熟悉阶段，我以为我把ss开了全局代理之后就能顺利走代理了，然而我错了，这个全局代理对终端是没有用的，最后发现终端还是需要单独设置代理的。 在终端下执行：12export http_proxy=socks5://127.0.0.1:1080 export https_proxy=socks5://127.0.0.1:1080 如果是http的代理，需要执行：12export http_proxy=http://127.0.0.1:1080/export https_proxy=http://127.0.0.1:1080/ 如果需要开机自动设置的话，可以直接把上面的代码加到~/.bash_profile里面就可以了。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac环境配置adb不起作用解决方案]]></title>
    <url>%2F2016%2F11%2F13%2FMac-set-adb%2F</url>
    <content type="text"><![CDATA[在mac下配置好了adb之后，发现每次要使用的话 都需要source .bash_profile后才能使用。这是一个大坑啊，索性就研究下如何避免这个操作。 经过查找原因之后，发现其实这个是zsh的锅，所以就去改zsh的配置文件了。 解决方案：在User目录在找到.zshrc文件，在文件的最后添加上12#Endble my profile source ~/.bash_profile]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2016%2F08%2F29%2FDesign-Pattern-Singleton%2F</url>
    <content type="text"><![CDATA[简述单例模式是应用最广的模式之一，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。 定义确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。 实现方式懒汉模式懒汉模式是声明一个静态对象，并且在用户第一次调用getInstance时进行初始化，其实现如下：12345678910111213public class Singleton &#123; private static Singleton instance; private Singleton() &#123; &#125; public static synchronized Singleton getInstance() &#123; if (null == instance) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优点：只有在使用时才会被实例化，在一定程度上节约了资源；缺点：第一次加载时需要及时进行实例化，反应稍慢，最大的问题是每次调用getInstance都进行同步，造成不必要的同步开销。这种模式一般不建议使用 参考 《Android源码设计模式-解析与实战》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design-Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Gradle配置]]></title>
    <url>%2F2016%2F08%2F25%2FGradle-config%2F</url>
    <content type="text"><![CDATA[从Android Studio第一版我就尝试用了，但一开始不太懂为啥配置这么麻烦，到慢慢版本更新，也越来越懂得Gradle是怎么一回事，到参考了些国外文章关于Gradle的配置后，近期差不多搞懂了些Gradle的配置，本文关于我个人的Gradle配置。 Default Config由于多项目管理总是需要配置Gradle和第三方包的依赖，然而不可能每次新开项目都要一个个去添加第三方依赖，所以我们可以统一管理起来，也给多个module统一管理Gradle。 在project的根目录下新建Config.gradle文件来统一管理基本配置。 Config.gradle文件如下：1234567891011121314151617ext &#123; supportVersion = &apos;23.4.0&apos; android = [compileSdkVersion: 23, buildToolsVersion: &quot;23.0.3&quot;, applicationId : &quot;me.f1reking.demo&quot;, minSdkVersion : 15, targetSdkVersion : 23, versionCode : 1, versionName : &quot;1.0&quot;] dependencies = [appcompatV7 : &quot;com.android.support:appcompat-v7:$&#123;supportVersion&#125;&quot;, supportV4 : &quot;com.android.support:support-v4:$&#123;supportVersion&#125;&quot;, design : &quot;com.android.support:design:$&#123;supportVersion&#125;&quot;, recyclerview : &quot;com.android.support:recyclerview-v7:$&#123;supportVersion&#125;&quot;, glide : &apos;com.github.bumptech.glide:glide:3.7.0&apos;] 然后在build.gradle文件添加apply from: &quot;config.gradle&quot; 作为文件引导 最后就可以在app的build.gradle使用配置了，如下：12345678910111213141516171819202122def config = rootProject.ext.android //android配置def dep = rootProject.ext.dependencies // 依赖配置compileSdkVersion config.compileSdkVersionbuildToolsVersion config.buildToolsVersiondefaultConfig &#123; applicationId config.applicationId minSdkVersion config.minSdkVersion targetSdkVersion config.targetSdkVersion versionCode config.versionCode versionName config.versionName&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) compile dep.appcompatV7 compile dep.supportV4 compile dep.design compile dep.recyclerview compile dep.glide&#125;]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxBus]]></title>
    <url>%2F2016%2F08%2F22%2FRxBus%2F</url>
    <content type="text"><![CDATA[之前项目用的是EventBus，最近项目开始用RxJava去替换些复杂的逻辑操作，所以可以用RxBus来替代EventBus，这样可以省去库的依赖，减小apk的大小。 RxJava此篇需要有RxJava的基础，关于RxJava，可以看扔物线的给 Android 开发者的 RxJava 详解. RxBus若对于RxJava有些了解，其RxBus的简单代码如下: 123456789101112131415161718192021222324252627282930public class RxBus &#123; private volatile static RxBus instance; private final Subject bus; public RxBus() &#123; bus = new SerializedSubject&lt;&gt;(PublishSubject.create()); &#125; public static RxBus getInstance() &#123; if (null == instance) &#123; synchronized (RxBus.class) &#123; if (null == instance) &#123; instance = new RxBus(); &#125; &#125; &#125; return instance; &#125; //提供一个事件传递 public void post(Object o) &#123; bus.onNext(o); &#125; // 根据传递的 eventType 类型返回特定类型(eventType)的 被观察者 public &lt;T&gt; Observable&lt;T&gt; toObserverable(Class&lt;T&gt; eventType) &#123; return bus.ofType(eventType); &#125;&#125; 使用方式发送事件的代码：1RxBus.getInstance().post(new Event(0)); Event是要发送的事件:1234567891011121314151617181920212223242526public class Event &#123; private String message; private int flag; public Event(String message) &#123; this.message = message; &#125; public Event(int flag) &#123; this.flag = flag; &#125; public Event(String message, int flag) &#123; this.message = message; this.flag = flag; &#125; public String getMessage() &#123; return message; &#125; public int getFlag() &#123; return flag; &#125;&#125; 接收事件的代码：12345678910111213141516// rxSubscription是一个Subscription的全局变量，这段代码可以在onCreate/onStart等生命周期内rxSubscription = RxBus.getDefault().toObserverable(Event.class) .subscribe(new Action1&lt;UserEvent&gt;() &#123; @Override public void call(Event event) &#123; String message = event.getMessage(); ... &#125; &#125;, new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; // TODO: 处理异常 &#125; &#125;); 最后 一定要记得在生命周期结束的地方取消订阅事件，防止RxJava可能会引起的内存泄漏问题。1234567@Overrideprotected void onDestroy() &#123; super.onDestroy(); if(!rxSubscription.isUnsubscribed()) &#123; rxSubscription.unsubscribe(); &#125;&#125;]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Java编程风格指南中文版]]></title>
    <url>%2F2016%2F07%2F17%2FGoogle-java-style%2F</url>
    <content type="text"><![CDATA[这是一篇关于 Google Java编程风格的指南书，摘抄自网上。 作者：Hawstein出处：http://hawstein.com/posts/google-java-style.html声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。 前言这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。 与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。 术语说明在本文档中，除非另有说明： 术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface) 术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。其他的术语说明会偶尔在后面的文档出现。 指南说明本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。 源文件基础文件名源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。 文件编码：UTF-8源文件编码格式为UTF-8。 特殊字符空白字符除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着： 所有其它字符串中的空白字符都要进行转义。 制表符不用于缩进。特殊转义序列对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。 非ASCII字符对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。 Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。 例如： 12345String unitAbbrev = "μs"; | 赞，即使没有注释也非常清晰String unitAbbrev = "\u03bcs"; // "μs" | 允许，但没有理由要这样做String unitAbbrev = "\u03bcs"; // Greek letter mu, "s" | 允许，但这样做显得笨拙还容易出错String unitAbbrev = "\u03bcs"; | 很糟，读者根本看不出这是什么return '\ufeff' + content; // byte order mark | Good，对于非打印字符，使用转义，并在必要时写上注释 Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 源文件结构一个源文件包含(按顺序地)： 许可证或版权信息(如有需要) package语句 import语句 一个顶级类(只有一个) 以上每个部分之间用一个空行隔开。 许可证或版权信息如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 package语句package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里) import语句import不要使用通配符即，不要出现类似这样的import语句：import java.util.*; 不要换行import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 顺序和间距import语句可分为以下几组，按照这个顺序，每组由一个空行分隔： 所有的静态导入独立成组 com.google imports(仅当这个源文件是在com.google包下) 第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun java imports javax imports 组内不空行，按字典序排列。 类声明只有一个顶级类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。 例外：package-info.java，该文件中可没有package-info类。 类成员顺序类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。 格式术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 大括号使用大括号(即使是可选的)大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。 非空块：K &amp; R 风格对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 示例： 1234567891011return new MyClass() &#123; @Override public void method() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125; &#125;&#125;; 4.8.1节给出了enum类的一些例外。 空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。 示例： 1void doNothing() &#123;&#125; 块缩进：2个空格每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例) 一行一个语句每个语句后要换行。 列限制：80或100一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。 例外： 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的 JSNI方法参考)。 package和import语句(见3.2节和3.3节)。 注释中那些可能被剪切并粘贴到shell中的命令行。 自动换行术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。 我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。 Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是 从哪里断开自动换行的基本准则是：更倾向于在更高的语法级别处断开。 如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（)，catch块中的管道符号(catch (FooException | BarException e) 如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。 自动换行时缩进至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 空白垂直空白以下情况需要使用一个空行： 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。 在函数体内，语句的逻辑分组间使用空行。 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。 要满足本文档中其他节的空行要求(比如3.3节：import语句)多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。 水平空白除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方： 分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。 分隔任何保留字与其前面的右大括号(})(如else, catch)。 在任何左大括号前({)，两个例外： @SomeAnnotation({a, b})(不使用空格)。 String[][] x = foo;(大括号间没有空格，见下面的Note)。 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号： 类型界限中的&amp;()。 catch块中的管道符号(catch (FooException | BarException e)。 foreach语句中的分号。 在, : ;及右括号())后 如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。 类型和变量之间：List list。 数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。 Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 水平对齐：不做要求术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。 这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。 以下示例先展示未对齐的代码，然后是对齐的代码： 12345private int x; // this is fineprivate Color color; // this tooprivate int x; // permitted, but future editsprivate Color color; // may leave it unaligned Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。 用小括号来限定组：推荐除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。 具体结构枚举类枚举常量间用逗号隔开，换行可选。 没有方法和文档的枚举类可写成数组初始化的格式：private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 变量声明 每次只声明一个变量 不要使用组合声明，比如int a, b;。 需要时才声明，并尽快进行初始化 不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 数组数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是OK的： 1234567891011121314151617new int[] &#123; 0, 1, 2, 3 &#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[]&#123;0, 1, 2, 3&#125; 非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 缩进与其它块状结构一致，switch块中的内容缩进为2个空格。 每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。 Fall-through：注释在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例： 1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; default的情况要写出来每个switch语句都包含一个default语句组，即使它什么代码也不包含。 注解(Annotations)注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如： 123@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125; 例外：单个的注解可以和签名的第一行出现在同一行。例如： @Override public int hashCode() { ... } 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如： @Partial @Mock DataLoader loader;参数和局部变量注解没有特定规则。 注释块注释风格块注释与其周围的代码在同一缩进级别。它们可以是/ … /风格，也可以是// …风格。对于多行的/ … /注释，后续行必须从开始， 并且与前一行的对齐。以下示例注释都是OK的。 1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/ … /。 Modifiers类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。 1public protected private abstract static final transient volatile synchronized native strictfp 命名约定对所有标识符都通用的规则标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。 标识符类型的规则包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。 类名类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。 方法名方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test_，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 常量名常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;; 这些名字通常是名词或名词短语。 非常量字段名非常量字段名以lowerCamelCase风格编写。 这些名字通常是名词或名词短语。 参数名参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 类型变量名类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写： 每个单词的第一个字母都大写，来得到大驼峰式命名。 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。 最后将所有的单词连接起来得到一个标识符。示例： 12345678Prose form Correct Incorrect------------------------------------------------------------------"XML HTTP request" XmlHttpRequest XMLHTTPRequest"new customer ID" newCustomerId newCustomerID"inner stopwatch" innerStopwatch innerStopWatch"supports IPv6 on iOS?" supportsIpv6OnIos supportsIPv6OnIOS"YouTube importer" YouTubeImporter YoutubeImporter* 加星号处表示可以，但不推荐。 Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。 编程实践@Override：能用则用只要是合法的，就把@Override注解给用上。 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 1234567try &#123; int i = Integer.parseInt(response); return handleNumericResponse(i);&#125; catch (NumberFormatException ok) &#123; // it's not numeric; that's fine, just continue&#125;return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125; 静态成员：使用类进行调用使用类名调用静态的类成员，而不是具体某个对象或表达式。 1234Foo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very bad Finalizers: 禁用极少会去重写Object.finalize。 Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。 Javadoc格式一般形式Javadoc块的基本格式如下所示： 12345/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125; 或者是以下单行形式： /** An especially short bit of Javadoc. */基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。 段落空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。 Javadoc标记标准的Javadoc标记按以下顺序出现：@param,@return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。 摘要片段每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或This method returns...开头, 它也不会是一个完整的祈使句，如Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 Tip：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。 哪里需要使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 例外：重写如果一个方法重写了超类中的方法，那么Javadoc并非必需的。 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenDAO数据库升级]]></title>
    <url>%2F2016%2F06%2F09%2FGreenDao%2F</url>
    <content type="text"><![CDATA[在使用greenDAO作为本地数据库操作时，会发现数据库升级无从下手，于是从爆栈网的答案中整理出了以下数据库升级方式的代码，感谢国外网友。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class MigrationHelper &#123; private static final String CONVERSION_CLASS_NOT_FOUND_EXCEPTION = "MIGRATION HELPER - CLASS DOESN'T MATCH WITH THE CURRENT PARAMETERS"; private static MigrationHelper instance; public static MigrationHelper getInstance() &#123; if (instance == null) &#123; instance = new MigrationHelper(); &#125; return instance; &#125; public void migrate(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; generateTempTables(db, daoClasses); DaoMaster.dropAllTables(db, true); DaoMaster.createAllTables(db, false); restoreData(db, daoClasses); &#125; private void generateTempTables(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String divider = ""; String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat("_TEMP"); ArrayList&lt;String&gt; properties = new ArrayList&lt;&gt;(); StringBuilder createTableStringBuilder = new StringBuilder(); createTableStringBuilder.append("CREATE TABLE ").append(tempTableName).append(" ("); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (getColumns(db, tableName).contains(columnName)) &#123; properties.add(columnName); String type = null; try &#123; type = getTypeByClass(daoConfig.properties[j].type); &#125; catch (Exception exception) &#123; &#125; createTableStringBuilder.append(divider).append(columnName).append(" ").append(type); if (daoConfig.properties[j].primaryKey) &#123; createTableStringBuilder.append(" PRIMARY KEY"); &#125; divider = ","; &#125; &#125; createTableStringBuilder.append(");"); db.execSQL(createTableStringBuilder.toString()); StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append("INSERT INTO ").append(tempTableName).append(" ("); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(") SELECT "); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(" FROM ").append(tableName).append(";"); db.execSQL(insertTableStringBuilder.toString()); &#125; &#125; private void restoreData(Database db, Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;... daoClasses) &#123; for (int i = 0; i &lt; daoClasses.length; i++) &#123; DaoConfig daoConfig = new DaoConfig(db, daoClasses[i]); String tableName = daoConfig.tablename; String tempTableName = daoConfig.tablename.concat("_TEMP"); ArrayList&lt;String&gt; properties = new ArrayList(); for (int j = 0; j &lt; daoConfig.properties.length; j++) &#123; String columnName = daoConfig.properties[j].columnName; if (getColumns(db, tempTableName).contains(columnName)) &#123; properties.add(columnName); &#125; &#125; StringBuilder insertTableStringBuilder = new StringBuilder(); insertTableStringBuilder.append("INSERT INTO ").append(tableName).append(" ("); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(") SELECT "); insertTableStringBuilder.append(TextUtils.join(",", properties)); insertTableStringBuilder.append(" FROM ").append(tempTableName).append(";"); StringBuilder dropTableStringBuilder = new StringBuilder(); dropTableStringBuilder.append("DROP TABLE ").append(tempTableName); db.execSQL(insertTableStringBuilder.toString()); db.execSQL(dropTableStringBuilder.toString()); &#125; &#125; private String getTypeByClass(Class&lt;?&gt; type) throws Exception &#123; if (type.equals(String.class)) &#123; return "TEXT"; &#125; if (type.equals(Long.class) || type.equals(Integer.class) || type.equals(long.class)) &#123; return "INTEGER"; &#125; if (type.equals(Boolean.class)) &#123; return "BOOLEAN"; &#125; Exception exception = new Exception(CONVERSION_CLASS_NOT_FOUND_EXCEPTION.concat(" - Class: ").concat(type.toString())); throw exception; &#125; private static List&lt;String&gt; getColumns(Database db, String tableName) &#123; List&lt;String&gt; columns = new ArrayList&lt;&gt;(); Cursor cursor = null; try &#123; cursor = db.rawQuery("SELECT * FROM " + tableName + " limit 1", null); if (cursor != null) &#123; columns = new ArrayList&lt;&gt;(Arrays.asList(cursor.getColumnNames())); &#125; &#125; catch (Exception e) &#123; Log.v(tableName, e.getMessage(), e); e.printStackTrace(); &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return columns; &#125;&#125; 使用方式：12345678910111213public class MyOpenHelper extends DaoMaster.OpenHelper &#123; public MyOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by migrating all tables data"); // 第二个参数为要升级的Dao文件. MigrationHelper.getInstance().migrate(db, xxxDao.class); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava与Retrofit实践总结]]></title>
    <url>%2F2016%2F03%2F23%2FRxJava-with-Retrofit%2F</url>
    <content type="text"></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava使用场景]]></title>
    <url>%2F2016%2F03%2F13%2FRxJava%2F</url>
    <content type="text"><![CDATA[研究了RxJava很久，最近才发现在实践中很难上手，所以此篇就是收集些使用场景 What RxJava一个词总结的很好：异步。RxJava在GitHub上自我介绍的是a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库)。 学RxJava此篇不讲解RxJava的基础，推荐两个地方的学习资料： 扔物线大大写的给 Android 开发者的 RxJava 详解 最近一直在学习的ReactiveX/RxJava文档中文版 RxJava使用场景RxBus代替EventBus进行数据传递 前几天研究了下RxBus，基本可以替代EventBus来使用，但注意的是RxBus并不是一个库，它只是一种模式，用RxJava的思想来实现替代EventBus的部分功能。此篇文章有讲解 使用merge来合并两个数据源例如要将两组数据合并成一组数据再转化成json传递给服务端，这是我们项目的场景。123456789101112131415161718192021Observable&lt;CartList&gt; observableCartList1 = Observable.from(cartList1);Observable&lt;CartList&gt; observableCartList2 = Observable.from(cartList2);Observable&lt;CartList&gt; observableCartList = Observable.merge(observableCartList1, observableCartList2);observableCartList.subscribe(new Observer&lt;CartList&gt;() &#123; @Override public void onCompleted() &#123; //数据组合完成后的操作 &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(CartList cartList) &#123; //数组组合时的操作 &#125; &#125;&#125;);]]></content>
      <categories>
        <category>RxJava</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坐在墙上]]></title>
    <url>%2F2016%2F02%2F17%2FSet-on-a-wall%2F</url>
    <content type="text"><![CDATA[25岁，第二个人生刚刚开始，而我却感觉坐在墙上。 去年刚刚走出校园，第二个人生阶段刚刚开始，一开始对未来的希望充满很大的想法，然而越走下去越偏离自己的梦想。于是，坚持走向梦想的我，选择了离开第一个公司，这也许是人生的一个重要决定，决定着以后的路要重新走，幸好我没有被公司的技术所框住，走自己的技术路，而越发现与公司越走越远。而今天感觉又遇到一个选择，一个很冒险的选择，一个新的挑战：加入初创公司，虽然能离我的梦想近一点，对技术能力成长得快，但很有风险，如果成功，我会长久待下去，带领公司团队走下去，如果失败，对于我，会对创业很反感了。所以，现在的我感觉坐在墙上，往左边跳是风险，往右边跳是安稳，但我还年轻，还可以犯错，所以这次我选择去冒这个风险，改变一下人生。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存小结]]></title>
    <url>%2F2016%2F02%2F17%2FJava-Memory%2F</url>
    <content type="text"><![CDATA[根据自己的理解总结下Java内存。 内存溢出内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 内存泄漏内存泄漏 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android控件解析-RecyclerView]]></title>
    <url>%2F2016%2F02%2F14%2FAndroid-RecyclerView%2F</url>
    <content type="text"><![CDATA[概述：RecyclerView已经出现很久了，现在我才来总结下，它是support-v7包的新组件，与经典的ListView相比，同样拥有item回收复用的功能，但是直接把viewholder的实现封装起来，用户只要实现自己的viewholder就可以了，该组件会自动帮你回收复用每一个item。 替代listview: 它封装了viewholder的回收复用 RecyclerView使用布局管理器管理子view的位置（目前尚只提供了LinearLayoutManager），也就是说你再不用拘泥于ListView的线性展示方式，如果之后提供其他custom LayoutManager的支持，你能够使用复杂的布局来展示一个动态组件。 自带了ItemAnimation，可以设置加载和移除时的动画，方便做出各种动态浏览的效果。 sample：1.xml: &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/my_recycler_view&quot; android:scrollbars=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android绘图整理]]></title>
    <url>%2F2016%2F02%2F08%2FAndroid-Drawer%2F</url>
    <content type="text"><![CDATA[对Android的绘图技术的整理 系统屏幕密度由于每个厂商的Android手机具有不同的大小尺寸和像素密度的屏幕。Android系统如果要精准到每种的DPI的屏幕，那是不可能的，因此，Android系统定义了几个标准的DPI值，作为手机的固定DPI。如下表所示： 密度 ldpi mdpi hdpi xhdpi xxhdpi 密度值 120 160 240 320 480 分辨率 240x320 320x480 480x800 720x1280 1080x1920 换算比例为：ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12 2D绘图基础系统通过提供的Canvas对象来提供绘图方法。Paintu作为一个重要的元素，其功能也是很强大的。比如： setAntiAlias(); //设置画笔的锯齿效果 setColor(); // 设置画笔的颜色 setARGB(); //设置画笔的A、R、G、B值 setAlpha(); //设置画笔的Alpha值 setTextSize(); //设置字体的尺寸 setStyle(); //设置画笔的风格(空心或实心) setStrokeWidth(); //设置空心边框的宽度 Canvas画布提供多种绘制方法，例如： drawLine //绘制直线 drawLines //绘制多条直线 drawRect //绘制矩形 drawCircle //绘制圆 drawText //绘制文本 drawPosText //在指定位置绘制文本 drawPoint //绘制点 drawRoundRect //绘制圆角矩形 drawArc //绘制弧形，扇形 drawOval //绘制椭圆 drawPath //绘制路径]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取assets的绝对路径]]></title>
    <url>%2F2016%2F01%2F23%2FAndroid-path-of-the-assets%2F</url>
    <content type="text"><![CDATA[第一种方法：1String path = "file:///android_asset/文件名" 第二种方法：1InputStream abpath = getClass().getResourceAsStream("/assets/文件名"); 若要想转换成String:123456789101112String path = new String(InputStreamToByte(abpath));private byte[] InputStreamToByte(InputStream is) throws IOException &#123; ByteArrayOutputStream bytestream = new ByteArrayOutputStream(); int ch; while ((ch = is.read()) != -1) &#123; bytestream.write(ch); &#125; byte imgdata[] = bytestream.toByteArray(); bytestream.close(); return imgdata;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android之CountDownTimer使用]]></title>
    <url>%2F2016%2F01%2F21%2FAndroid-CountDownTimer%2F</url>
    <content type="text"><![CDATA[之前做项目的时候都是自己写个倒计时的代码来控制发生验证码的倒计时，最近在学习中才发现原来Android中已经帮我们封装了一个倒计时代码，因此学习用起。 Code12345678910private CountDownTimer mCountDownTimer = new CountDownTimer(60000,1000) &#123; @Override public void onTick(long millisUntilFinished) &#123; mBtnDown.setText((millisUntilFinished/1000)+"秒后可重发"); &#125; @Override public void onFinish() &#123; mBtnDown.setText("重新获取验证码"); &#125; &#125;; 最终执行mCountDownTimer.start(); 构造函数public CountDownTimer (long millisInFuture, long countDownInterval)参数millisInFuture 从开始调用start()到倒计时完成并onFinish()方法被调用的毫秒数。（倒计时时间，单位毫秒）countDownInterval 接收onTick(long)回调的间隔时间。（单位毫秒） 公共方法public final void cancel ()取消倒计时（取消后，再次启动会重新开始倒计时） public abstract void onFinish ()倒计时完成时被调用 public abstract void onTick (long millisUntilFinished)固定间隔被调用参数millisUntilFinished 倒计时剩余时间。 public synchronized final CountDownTimer start ()启动倒计时 例图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio问题集锦]]></title>
    <url>%2F2016%2F01%2F13%2FAndroid-Studio-Collection-Problems%2F</url>
    <content type="text"><![CDATA[从Android Studio发布时我就开始用了，一直以来版本的迭代出现很多bug问题和软件使用问题，但这些在近来的版本都解决了，所以这里记录下平时使用遇到的软件和bug问题。 Android Studio - no debuggable applications在使用Android Studio的时候有碰过这个问题，看不到所要调试的app选项。 经过研究后，通过 Tools-&gt;Android-&gt;Enable ADB Integration active. 即可解决问题。 本文原文发自 F1ReKing, 转载请保留出处, 谢谢.]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bye2015Hi2016]]></title>
    <url>%2F2015%2F12%2F31%2FBye2015Hi2016%2F</url>
    <content type="text"><![CDATA[Be the change you want to see in the world. 过去的2015年，是离开大学毕业的那一年，是工作的第一年，是为梦想而放弃目前工作的一年。无论如何，过去的一年是一个开始，但也是一个结束，开始的是做Android开发，结束的是离开我不喜欢的工作岗位。 2016年也许是改变自我关键的一年，但愿在明年今日再来看此篇，会是心满意足。 2016的计划：1.书单: [x] 《Java编程思想》 [x] 《Android群英传》 [x] 《Android开发艺术探索》 [x] 《Android源码设计模式》 [ ] 《设计模式之禅》 2.减重：为了能应付高强度的脑力工作和长时间久坐的积劳，决定健身减肥，减轻到身体能承受工作。 3.购物清单： [x] MBR [x] Dell U2414H显示器 [x] 自组装山地自行车 4.拥抱计划：计划都是会变化的，拥抱好这份计划。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作第一年]]></title>
    <url>%2F2015%2F12%2F31%2FFirst-work%2F</url>
    <content type="text"><![CDATA[工作满一年了…]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发规范(编码+性能+UI)]]></title>
    <url>%2F2015%2F08%2F01%2FAndroid-development-specifications%2F</url>
    <content type="text"><![CDATA[从事Android开发半年以来，我始终觉得自己的Android规范很不行，每个项目都不一样，所以我找了些网上的规范整理出来，以后我的项目会按照这个规范去做应用。 一、Android编码规范 java代码中不出现中文，最多注释中可以出现中文 局部变量命名、静态成员变量命名只能包含字母，单词首字母出第一个外，都为大写，其他字母都为小写。 常量命名只能包含字母和，字母全部大写，单词之间用隔开。 layout中的id命名命名模式为： view缩写_模块名称_view的逻辑名称view的缩写详情如下： LayoutView：lv RelativeView:rv TextView:tv ImageView:iv ImageButton:im Button:btn activity中的view变量命名命名模式为：逻辑名称+view缩写 建议：如果layout文件很复杂，建议将layout分成多个模块，每个模块定义一个moduleViewHolder，其成员变量包含所属view strings.xml中的id命名命名模式：activity名称功能模块名称逻辑名称/activity名称逻辑名称/common逻辑名称strings.xml中，使用activity名称注释，将文件内容区分开来。 drawable中的图片命名命名模式：activity名称逻辑名称/common逻辑名称 styles.xml：将layout中不断重现的style提炼出通用的style通用组件，放到styles.xml中； 使用layer-list和selector 图片尽量分拆成多个可重用的图片 服务端可以实现的，就不要放在客户端 引用第三方库要慎重，避免应用大容量的第三方库，导致客户端包非常大 处理应用全局异常和错误，将错误以邮件的形式发送给服务端 图片的.9处理 使用静态变量方式实现界面间共享要慎重 Log(系统名称 模块名称 接口名称，详细描述) 单元测试（逻辑测试、界面测试） 不要重用父类的handler，对应一个类的handler也不应该让其子类用到，否则会导致message.what冲突 activity中在一个View.OnClickListener中处理所有的逻辑 strings.xml中使用%1$s实现字符串的通配 如果多个Activity中包含共同的UI处理，那么可以提炼一个CommonActivity，把通用部分叫由它来处理，其他activity只要继承它即可 使用button+activitgroup实现tab效果时，使用Button.setSelected(true)，确保按钮处于选择状态，并使activitygroup的当前activity与该button对应 如果所开发的为通用组件，为避免冲突，将drawable/layout/menu/values目录下的文件名增加前缀 数据一定要效验，例如字符型转数字型，如果转换失败一定要有缺省值；服务端响应数据是否有效判断； 同一个客户端如果要放在不同的市场，而且要统计各个市场下载及使用数据时针对不同的客户端打不同的包，唯一的区别是versionName，apk文件名为versionName.apk。在升级时，要将自己的versionCode和versionName一并传给服务端，如果需要升级，则下载versionName相对应的apk关于是否要强制升级： 1).不管何种情况都强制升级 2).判断用户的版本和当前最新版本，如果兼容则强制升级，否则可选； 有的按钮要避免重复点击 二、Android性能优化 http用gzip压缩，设置连接超时时间和响应超时时间http请求按照业务需求，分为是否可以缓存和不可缓存，那么在无网络的环境中，仍然通过缓存的httpresponse浏览部分数据，实现离线阅读. listview 性能优化 1)复用convertView在getItemView中，判断convertView是否为空，如果不为空，可复用。如果couvertview中的view需要添加listerner，代码一定要在if(convertView==null){}之外。 2)异步加载图片 item中如果包含有webimage，那么最好异步加载 3)快速滑动时不显示图片当快速滑动列表时（SCROLL_STATE_FLING），item中的图片或获取需要消耗资源的view，可以不显示出来；而处于其他两种状态（SCROLL_STATE_IDLE 和SCROLL_STATE_TOUCH_SCROLL），则将那些view显示出来 4)list中异步加载的图片，当不在可视范围内，按照一定的算法及时回收（如在当前可视范围的上下10条item以外的图片进行回收，或者将图片进行缓存，设置一个大小，按照最近最少使用原则超过部分进行回收） 5)BaseAdapter避免内存溢出如果BaseAdapter的实体类有属性非常消耗内存，可以将保存到文件；为提高性能，可以进行缓存，并限制缓存大小。 使用线程池，分为核心线程池和普通线程池，下载图片等耗时任务放置在普通线程池，避免耗时任务阻塞线程池后，导致所有异步任务都必须等待 异步任务，分为核心任务和普通任务，只有核心任务中出现的系统级错误才会报错，异步任务的ui操作需要判断原activity是否处于激活状态 1)主线程不要进行网络处理； 2)主线程不要进行数据库处理； 3)主线程不要进行文件处理； 尽量避免static成员变量引用资源耗费过多的实例，比如Context .使用WeakReference代替强引用，弱引用可以让您保持对对象的引用，同时允许GC在必要时释放对象，回收内存。对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。 超级大胖子Bitmap及时的销毁(Activity的onDestroy时将bitmap回收，在被UI组件使用后马上进行回收会抛RuntimeException: Canvas: trying to use a recycled bitmap android.graphics.Bitmap) 设置一定的采样率(有开发者提供的图片无需进行采样，对于有用户上传或第三方的大小不可控图片，可进行采样减少图片所占的内存)，从服务端返回图片，建议同时反馈图片的size 巧妙的运用软引用 drawable对应resid的资源，bitmap对应其他资源 任何类型的图片，如果获取不到（例如文件不存在，或者读取文件时跑OutOfMemory异常），应该有对应的默认图片（默认图片放在在apk中，通过resid获取）； 保证Cursor 占用的内存被及时的释放掉，而不是等待GC来处理。并且 Android明显是倾向于编 程者手动的将Cursor close掉 线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控 如果ImageView的图片是来自网络，进行异步加载 应用开发中自定义View的时候，交互部分，千万不要写成线程不断刷新界面显示，而是根据TouchListener事件主动触发界面的更新 Drawableui组件需要用到的图片是apk包自带的，那么一律用setImageResource或者setBackgroundResource，而不要根据resourceid注意：get(getResources(), R.drawable.btn_achievement_normal)该方法通过resid转换为drawable，需要考虑回收的问题，如果drawable是对象私有对象，在对象销毁前是肯定不会释放内存的。 复用、回收Activity对象临时的activity及时finish 主界面设置为singleTask 一般界面设置为singleTop 位置信息获取用户的地理位置信息时，在需要获取数据的时候打开GPS，之后及时关闭掉 在onResume时设置该界面的电源管理，在onPause时取消设置 三、AndroidUI优化 layout组件化，尽量使用merge及include复用 使用styles，复用样式定义 软键盘的弹出控制，不要让其覆盖输入框 数字、字母和汉字混排占位问题：将数字和字母全角化。由于现在大多数情况下我们的输入都是半角，所以 字母和数字的占位无法确定，但是一旦全角化之后，数字、字母的占位就和一个汉字的占位相同了，这样就可以避免由于占位导致的排版问题。 英文文档排版：textview自动换行时要保持单词的完整性，解决方案是计算字符串长度，然后手动设定每一行显示多少个字母并加上‘\n‘ 复杂布局使用RelativeLayout 自适应屏幕，使用dp替代pix 使用android:layout_weight或者TableLayout制作等分布局 使用animation-list制作动画效果 本文原文发自 F1ReKing, 转载请保留出处, 谢谢.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用wifi来调试Android程序]]></title>
    <url>%2F2015%2F06%2F21%2FUse-wifi-to-debug-the-program%2F</url>
    <content type="text"><![CDATA[以前自学Android时总是要通过usb线来连接真机调试，然而在我usb线不稳定的情况下，我试着找寻能不能用wifi来调试android程序，这个方法是可行的。条件： 手机与电脑同一个wifi局域网下 Android studio我试过，Eclipse没试过 方法： 要先知道你手机的网络ip是什么，这里我选择用app来查找，通过http://pan.baidu.com/s/1dD1u2eH 下载wifi adb （需要root权限）App来查找手机ip。 首先要先把SDK\platform-tools下的adb.exe、AdbWinApi.dll、AdbWinUsbApi.dll复制到C:\Windows\System32和C:\Windows\SysWOW64（系统64位才需要）下。 用管理员模式运行命令行管理器，并输入wifi adb应用上的提示。 此时在Android Devices上就可以看到连接的手机了，可以直接调试操作了，到这里，你再也不用担心因为usb口不稳定而不好调试，只要你的wifi是稳定的，可以很轻松的进行真机调试应用了。 本文原文发自 F1ReKing, 转载请保留出处, 谢谢.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
</search>